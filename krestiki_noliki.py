from typing import List, Union # для аннотирования (совместимость версий python)


# приоритетным языком является RUNGLISH

# Объявление переменных

init_symb = "-" # элемент для первоначального заполнения таблицы
x_symb = "Х" # обозначение крестиков
n_symb = "О" # обозначение ноликов
size = 1 # от Размер доски (дальнейший ввод через input)
win_count = 3 # Cколько нужно проставить подряд крестиков/ноликов для победы. (дальнейший ввод через input)
first_ascii = ord("Г") # ascii код названия первого столбца
rep_move_str = "\nСделайте повторный ход!" # используется в нескольких случаях
sep_s = "\t " # разделитель, использующийся для вывода таблицы

text = "Игра Крестики-Нолики.\n" + \
       "Вы можете выбрать размер игрового поля и\n" + \
       "выбрать сколько крестиков/ноликов нужно поставить для победы."

# словарь для небольшого улучшения информирования пользователей
# в завимости от того кто победил крестики или нолики
xn_dict = {
    x_symb: "крестики",
    n_symb: "нолики"
}

# решил сделать через декоратор обработку ввода значений
# удаление лишних пробелов и перевод в верхний регистр
# всех функций my_input (которая просто возвращает input с передаваемыми параметрами)
def decorator(func):
    def wrapper(*args, **kwargs):
        res = func(*args, **kwargs)

        return res.replace(" ", "").strip().upper()  # Изменяем возвращаемое значение в wrapper'
    return wrapper

@decorator
def my_input(*args, **kwargs):
    return input(*args, **kwargs)


# выводится приветствие, после которого
# вводятся основные параметры игры (размер поля, кол-во крестиков/ноликов для победы)
# на основании введённого размера поля строится игровая таблица
def before_game() ->Union[List[str], List[str], List[List[int]], int, int]:
    # функция не принимает параметры
    # вовзращает:
    # lst_rows - список с названиями строк игровой таблицы
    # lst_cols - список с названиями столбцов игровой таблицы
    # board - игровая таблица (список списков)
    # size - размер игровой таблицы (int) (можно получить len игровой таблицы, для ясности решил передать отдельно)
    # win_count - кол-во крестиков/ноликов для победы (int)


    print(text) # печать названия игры и пр.

    while True:
        str_size = my_input("Введите размер игровой таблицы (ЦЕЛОЕ ЧИСЛО от 3 до 10) - ")

        if str_size.isdigit():
            size = int(str_size)
            if 3 <= size <= 10:
                break
        print("Введите правильное значение размера игровой таблицы")

    while True:
        str_win_count = my_input("Введите сколько крестиков/ноликов нужно поставить для победы\n" + \
                            f"(ЦЕЛОЕ ЧИСЛО от 2 до {size}) - "
                            )

        if str_win_count.isdigit():
            win_count = int(str_win_count)
            if 2 <= win_count <= win_count:
                break
        print("Введите правильное значение количества крестиков/ноликов")

    print("\nИгра началась!\n")
    # создание игровой таблицы и её первоначальное заполнений
    # создание списка (строки) списков (столбцы) (по сути двумерный массив)
    board =[ [ init_symb for j in range(size)] for i in range(size) ]


    # с помощью ascii кодов задание букв отображения названий столбцов игры
    lst_cols = list( map(chr, range(first_ascii, first_ascii + size)) )
    # задание цифр отображения названий строк игры
    lst_rows = list( map(str, range(1, size + 1)) )

    return lst_rows, lst_cols, board, size, win_count



# проверка есть ли победитель
# определяется в зависимости от размера игровой таблицы и
# победного числа (win_count - сколько нужно крестиков/ноликов для победы)
def check_lst_field(board: List[List[int]], xn: str, size: int, win_count:int) -> bool:
    # board - иторовая таблица двумерный массив (список списков)
    # xn - проверяемый на победу крестик/нолик (символ/строка)
    # size - размер игровой таблицы (int) (можно получить len игровой таблицы, для ясности решил передать отдельно)
    # win_count - кол-во крестиков/ноликов для победы (int)
    # функцмя check_lst_field возвращает результат проверки True если есть победитель False нет победителя


    # проверка на равенство крестику/нолику
    # заданного количества (win_count) элементов (столбцов в каждой строке)
    # проверка для всех строк, есть ли в столбцах этой строки необходимое для победы
    # количество/крестиков ноликов
    # проверка есть ли хоть один подряд список True
    # i (строка) меняется стандартно j (столбец) задаётся
    # в зависимости от размера (size) и количества креcтиков/ноликов необходимых для победы (win_count)
    for i in range(size):
        if any(
                [
                    all([board[i][j] == xn  for j in range(j_init, j_init + win_count)]) \
                        for j_init in range(size - win_count + 1)
                ]
        ):
            return True

    # проверка на равенство крестику/нолику
    # заданного количества (win_count) элементов (строк в каждом столбце)
    # j (столбец) меняется стандартно i (строка) задаётся
    # в зависимости от размера (size) и количества креcтиков/ноликов необходимых для победы (win_count)
    for j in range(size):
        if any(
                [
                    all([board[i][j] == xn for i in range(i_init, i_init + win_count)]) \
                        for i_init in range(size - win_count + 1)
                ]
        ):
            return True

    # проверка по диагоналям
    # сначала задаются отправные индексы, с которых будет строится каждая диагональ
    # инжексы первой диагоналт (главная)
    pioneer_indexes = [ (i, j)  for i in range(size - win_count + 1) for j in range(size - win_count + 1) ]
    # затем для каждого отправного индекса строятся диагонали (dg_pioneer)
    # (фактически это список индеков в зависимости от необходимого для победы win_count)
    # и проверяется все ли элементы этой диагонали равны крестику/нолику
    for i_init, j_init  in pioneer_indexes:
        dg_pioneer = list(
            zip(range(i_init, i_init + win_count), range(j_init, j_init + win_count))
        ) # пионерская диагональ
        if all( [ board[i][j] == xn for i, j in dg_pioneer ] ):
            return True

    # аналогично для неглавной диагонали
    anti_pioneer_indexes = list(map(lambda x: (x[0], size - x[1] - 1), pioneer_indexes))
    for i_init, j_init in anti_pioneer_indexes:
        dg_anti_pioneer = list(
            zip(range(i_init, i_init + win_count), range(j_init, j_init - win_count, -1))
        ) # антипионерская диагональ
        if all( [ board[i][j] == xn for i, j in dg_anti_pioneer ] ):
            return True


    return False


# функция, в которой и происходит Игра
def game(lst_rows: List[str], lst_cols: List[str], board: List[List[int]], size: int, win_count: int):
    # аргументы функции:
    # lst_rows - список с названиями строк игровой таблицы
    # lst_cols - список с названиями столбцов игровой таблицы
    # board - игровая таблица (список списков)
    # size - размер игровой таблицы (int) (можно получить len игровой таблицы, для ясности решил передать отдельно)
    # win_count - кол-во крестиков/ноликов для победы (int)


    cw = 0 # задание счётчика ходов таблицы
    xn = x_symb # задание крестика

    # цикл игры
    # для повтора хода используется continue
    # для выхода используется break
    while True:

        # вывод игровой таблицы
        print("\t", sep_s.join(lst_cols), "\n") # вывод букв столбцов
        # для всех строк игрового поля
        # вывод цифр строк и текущих данных игровой таблицы
        for i in range(size):
            print(lst_rows[i],"\t" ,sep_s.join(board[i]), "\n")

        # проверка есть ли победитель,
        # есле нет, то проверяем все ли ходы сделаны, заполнено ли всё поле
        if check_lst_field(board, xn, size, win_count):
            print(f"Победили {xn} {xn_dict[xn]}")
            break
        elif cw == size ** 2:
            print(f"Ничья крестико-ноликовая!")
            break

        # если счётчик ходов чётный, то
        # ход крестика, иначе ход нолика
        if cw % 2 == 0:
            xn = x_symb
        else:
            xn = n_symb

        cr = my_input(f"Введите в каком столбце и ряду ставить {xn} (например, Г1, как при игре в Морской бой) - ")

        # для игнорирования регистра введеного символа
        # и на случай если ввели с пробелами работает декоратор (определён для my_input выше)
        # cr = cr.replace(" ","").strip().upper()

        # если введён символ выхода (клавиша, где Ъ/]), то выход
        if cr == "Ъ" or cr == "]":
            print("Вы вышли из игры")
            break

        # проверка введённой строки, если неправильный ввод, то повторяем его
        if len(cr) > 2:
            print("Вы ввели слишком много символов" + rep_move_str)
            continue
        if cr[0] not in lst_cols:
            print(f"Столбца с буквой {cr[0]} нет." + rep_move_str)
            continue
        if cr[1] not in lst_rows:
            print(f"Строки {cr[1]} нет." + rep_move_str)
            continue

        # соответствие между введёнными данными и
        # индексами массива игрового поля
        r = lst_rows.index(cr[1])
        c = lst_cols.index(cr[0])

        # проверка стоит ли уже Крестик или Нолик во введённой ячейки игрового поля,
        # то есть проверка стоит ли символ первоначального заполнения таблицы
        # в этом месте
        # если стоит, то повторный ход
        if board[r][c] != init_symb:
            print(f"В указанной ячейке {cr} уже стоит {board[r][c]}." + rep_move_str)
            continue # повторный ход

        # иначе ставим новое значение крестика/нолика в таблицу
        # и увеличиваем счётчик ходов на 1
        board[r][c] = xn
        cw += 1 # увеличиваем счётчик ходов на 1



# Запуск игры, функция сразу принимает аргументы возвращаемые после запуска другой функции
game(*before_game())